--================================================================
-- CONNECT BY 를 이용한 계층 쿼리
--================================================================
SELECT * FROM tdept;

-- 사장실 등록
insert into tdept (dept_code,dept_name, parent_dept, use_yn, area, boss_id)
values ('000000','사장실','  ','Y','서울','');

-- 상위부서 적용
update tdept 
set parent_dept='000000' where dept_code=parent_dept;

SELECT * FROM tdept; -- 11개

-- 부서를 상위부서부터 차례대로 단계를 붙여서 출력해보자!
SELECT
	LEVEL, DEPT_CODE , DEPT_NAME 
FROM 
	TDEPT 
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT ; -- 28개 : 모든 단계를 표시
	
SELECT
	LEVEL, DEPT_CODE , DEPT_NAME 
FROM 
	TDEPT 
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT START WITH DEPT_CODE = '000000'; -- 11개 : 최상위 부서를 지정
	
SELECT
	LEVEL, DEPT_CODE , DEPT_NAME 
FROM 
	TDEPT 
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT START WITH DEPT_CODE = 'AA0001'; -- 3개 : 경영지원 부서를 지정
	
SELECT
	LEVEL, LPAD(DEPT_CODE,LEVEL*5,' ') , LPAD(DEPT_NAME,LEVEL*8,' '), LPAD(' ',LEVEL*8, ' ')||DEPT_NAME 
FROM 
	TDEPT 
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT START WITH DEPT_CODE = '000000'; 
	
-- 조건을 where절에 주면 문제가 발생한다.
-- 영업 부서는 제외하여 조회하고싶다.
SELECT
	LEVEL, LPAD(DEPT_CODE,LEVEL*5,' ') , LPAD(DEPT_NAME,LEVEL*8,' '), LPAD(' ',LEVEL*8, ' ')||DEPT_NAME 
FROM 
	TDEPT
WHERE 
	DEPT_CODE <> 'CA0001' -- 상우; 부서명만 사라져서 영업지원 내의 부서들이 기술지원으로 들어감
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT START WITH DEPT_CODE = '000000'; 

SELECT 
	LEVEL, LPAD(DEPT_CODE,LEVEL*5,' ') , LPAD(DEPT_NAME,LEVEL*8,' '), LPAD(' ',LEVEL*8, ' ')||DEPT_NAME 
FROM 
	TDEPT
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT AND DEPT_CODE <> 'CA0001' -- 여기에 조건을 부여해야 모든 영업부서들이 제외된다.
	START WITH DEPT_CODE = '000000'; 
-- START WITH 값을 변경하면 원하는 레벨의 값만 조회가 가능하다.
-- 기술지원부만 보고싶다.
SELECT 
	LEVEL, LPAD(DEPT_CODE,LEVEL*5,' ') , LPAD(' ',LEVEL*8, ' ')||DEPT_NAME 
FROM 
	TDEPT
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT
	START WITH DEPT_CODE = 'BA0001'; 
	
-- 영업부만 보고싶다.
SELECT 
	LEVEL, LPAD(DEPT_CODE,LEVEL*5,' ') , LPAD(' ',LEVEL*8, ' ')||DEPT_NAME 
FROM 
	TDEPT
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT
	START WITH DEPT_CODE = 'CA0001'; 

-- 역전개의 잘못된 방법
SELECT 
	LEVEL, LPAD(DEPT_CODE,LEVEL*5,' ') , LPAD(' ',LEVEL*8, ' ')||DEPT_NAME 
FROM 
	TDEPT
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT -- 여기를 변경하지 않으면 역전개가 되지않는다.
	START WITH DEPT_CODE = 'CD0001'; -- 시작위치만 바꾸면 역전개가 되지 않는다.

-- 역전개
SELECT 
	LEVEL, LPAD(DEPT_CODE,LEVEL*5,' ') , LPAD(' ',LEVEL*8, ' ')||DEPT_NAME 
FROM 
	TDEPT
CONNECT BY 
	PRIOR PARENT_DEPT = DEPT_CODE -- 여기를 변경하지 않으면 역전개가 되지않는다.
	START WITH DEPT_CODE = 'CD0001'; -- 시작위치만 바꾸면 역전개가 되지 않는다.

-- 부서장의 이름이 단계별로 나오게 하시오!
-- 1) 부서장의 ID가 나온다.
SELECT 
	LEVEL,LPAD(' ',LEVEL*8, ' ')||DEPT_NAME , LPAD(BOSS_ID, LEVEL*6, ' ') 
FROM 
	TDEPT
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT -- 여기를 변경하지 않으면 역전개가 되지않는다.
	START WITH DEPT_CODE = '000000'; -- 시작위치만 바꾸면 역전개가 되지 않는다.

-- 2) 부서장의 이름은 temp테이블에 있다. 1의 결과와 조인을 하면 부서명과 부서장의 이름을 모두 조회가 가능하다.
SELECT 
	 B.LEV, B.DEPT_NAME, NVL(A.EMP_NAME,' ')
FROM 
	TEMP A,
	(SELECT LEVEL LEV, DEPT_NAME , LPAD(BOSS_ID, LEVEL*6, ' ') BOSS FROM TDEPT 
	CONNECT BY PRIOR DEPT_CODE = PARENT_DEPT START WITH DEPT_CODE = '000000') B
WHERE
	A.EMP_ID(+) = B.BOSS;
	

--============================================================================================
-- 5장. 랭킹
--============================================================================================

CREATE TABLE SALE_HIST(
  SALE_DATE  DATE NOT NULL,
  SALE_SITE  VARCHAR2(10) NOT NULL,
  SALE_ITEM  VARCHAR2(10) NOT NULL,
  SALE_AMT   NUMBER,
  CONSTRAINT SALEHIST_PK PRIMARY KEY (SALE_DATE,SALE_SITE,SALE_ITEM)
);
INSERT INTO SALE_HIST VALUES('20010501','01','PENCIL',  5000);
INSERT INTO SALE_HIST VALUES('20010501','01','NOTEBOOK',9000);
INSERT INTO SALE_HIST VALUES('20010501','01','ERASER',  4500);
INSERT INTO SALE_HIST VALUES('20010501','02','PENCIL',  2500);
INSERT INTO SALE_HIST VALUES('20010501','02','NOTEBOOK',7000);
INSERT INTO SALE_HIST VALUES('20010501','02','ERASER',  3000);
INSERT INTO SALE_HIST VALUES('20010501','03','PENCIL',  2500);
INSERT INTO SALE_HIST VALUES('20010501','03','NOTEBOOK',7000);
INSERT INTO SALE_HIST VALUES('20010501','03','ERASER',  6000);
--
INSERT INTO SALE_HIST VALUES('20010502','01','PENCIL',  6000);
INSERT INTO SALE_HIST VALUES('20010502','01','NOTEBOOK',5000);
INSERT INTO SALE_HIST VALUES('20010502','01','ERASER',  5500);
INSERT INTO SALE_HIST VALUES('20010502','02','PENCIL',  3500);
INSERT INTO SALE_HIST VALUES('20010502','02','NOTEBOOK',7000);
INSERT INTO SALE_HIST VALUES('20010502','02','ERASER',  4000);
INSERT INTO SALE_HIST VALUES('20010502','03','PENCIL',  5500);
INSERT INTO SALE_HIST VALUES('20010502','03','NOTEBOOK',4500);
INSERT INTO SALE_HIST VALUES('20010502','03','ERASER',  5000);
--
INSERT INTO SALE_HIST VALUES('20010503','01','PENCIL',  7000);
INSERT INTO SALE_HIST VALUES('20010503','01','NOTEBOOK',6000);
INSERT INTO SALE_HIST VALUES('20010503','01','ERASER',  6500);
INSERT INTO SALE_HIST VALUES('20010503','02','PENCIL',  3500);
INSERT INTO SALE_HIST VALUES('20010503','02','NOTEBOOK',5000);
INSERT INTO SALE_HIST VALUES('20010503','02','ERASER',  5000);
INSERT INTO SALE_HIST VALUES('20010503','03','PENCIL',  6500);
INSERT INTO SALE_HIST VALUES('20010503','03','NOTEBOOK',3500);
INSERT INTO SALE_HIST VALUES('20010503','03','ERASER',  7000);
--
INSERT INTO SALE_HIST VALUES('20010504','01','PENCIL',  5500);
INSERT INTO SALE_HIST VALUES('20010504','01','NOTEBOOK',6500);
INSERT INTO SALE_HIST VALUES('20010504','01','ERASER',  3500);
INSERT INTO SALE_HIST VALUES('20010504','02','PENCIL',  7500);
INSERT INTO SALE_HIST VALUES('20010504','02','NOTEBOOK',5000);
INSERT INTO SALE_HIST VALUES('20010504','02','ERASER',  4000);
INSERT INTO SALE_HIST VALUES('20010504','03','PENCIL',  3500);
INSERT INTO SALE_HIST VALUES('20010504','03','NOTEBOOK',5500);
INSERT INTO SALE_HIST VALUES('20010504','03','ERASER',  3000);
COMMIT;

SELECT * FROM SALE_HIST sh;

-- 순위 구하기
SELECT 
	EMP_ID , EMP_NAME, SALARY ,
	DENSE_RANK () OVER(ORDER BY SALARY DESC) AS 순위1, -- 동률처리 방식이 다름
	RANK () OVER(ORDER BY SALARY DESC) AS 순위2,
	RANK () OVER(ORDER BY SALARY ) AS 순위3
FROM 
	TEMP;
-- 부서별 급여기준 순위를 보고싶다.
-- 1) 부서별 급여 합계
SELECT 
	DEPT_CODE , SUM(SALARY) 
FROM 
	TEMP t 
GROUP BY
	DEPT_CODE ;

-- 2) 1의 결과에 순위를 출력
SELECT 
	DEPT_CODE , SUM(SALARY) , RANK() OVER(ORDER BY SUM(SALARY) DESC) 순위
FROM 
	TEMP t 
GROUP BY
	DEPT_CODE ;

-- rollup이나 cube의 결과에까지 순위를 적용해 보자
-- 부서별 급여 합계 순위
SELECT 
	DEPT_CODE , EMP_ID , SUM(SALARY),
	RANK() OVER (PARTITION BY GROUPING(DEPT_CODE), GROUPING (EMP_ID) ORDER BY sum(SALARY)DESC)
FROM 
	TEMP t 
GROUP BY
	ROLLUP (DEPT_CODE, EMP_ID );

-- 문제] sale_hits의 자료를 이용하여 일자별 매출 순위와 순위별 사업장 품목을 보여라!
SELECT * FROM SALE_HIST sh;

SELECT 
	sh.*,
	rank() OVER (PARTITION BY SALE_DATE ORDER BY SALE_AMT desc) 순위
FROM 
	SALE_HIST sh ;

SELECT 
	sh.*,
	rank() OVER (PARTITION BY SALE_SITE ORDER BY SALE_AMT desc) 순위
FROM 
	SALE_HIST sh ;

-- CUME_DIST, PERCENT_RANK, NTILE(N), ROW_NUMBER()

SELECT 
	EMP_ID , EMP_NAME , SALARY ,
	rank() OVER (ORDER BY SALARY ) 순위1,           -- 순위를 자연수로 표시
	CUME_DIST() OVER (ORDER BY SALARY ) 순위2,		-- 순위를 0~1사이 실수로 표시
	PERCENT_RANK() OVER (ORDER BY SALARY ) 순위3,  	-- 퍼센트
	NTILE(5) OVER (ORDER BY SALARY ) 순위4,			-- n개의 그룹으로 나눈다.
	ROW_NUMBER() OVER (ORDER BY SALARY ) 순위5		-- 파티션 내의 실행된 ROW 순서의 일련번호
FROM 
	TEMP ;

-- 입사년도별 급여의 합계를 구하라
SELECT 
	SUBSTR(EMP_ID, 1,4), SUM(SALARY) 
FROM 
	TEMP 
GROUP BY 
	SUBSTR(EMP_ID, 1, 4); 

-- 입사년도별 차례대로 전부 나오게 하려면
SELECT 
	SUBSTR(EMP_ID, 1,4),EMP_ID , EMP_NAME ,SUM(SALARY) 
FROM 
	TEMP 
GROUP BY 
	SUBSTR(EMP_ID, 1, 4),EMP_ID , EMP_NAME 
ORDER BY 1;

-- 순위는 어떻게 구할까?
-- 위의 5개 함수를 이용하여 모두 조회해 보자
SELECT 
	SUBSTR(EMP_ID, 1,4) 입사년도,EMP_ID , EMP_NAME ,SUM(SALARY),
	RANK () OVER(PARTITION BY SUBSTR(EMP_ID, 1, 4) ORDER BY SALARY ) rank1,
	CUME_DIST () OVER(PARTITION BY SUBSTR(EMP_ID, 1, 4) ORDER BY SALARY ) rank2,
	PERCENT_RANK () OVER(PARTITION BY SUBSTR(EMP_ID, 1, 4) ORDER BY SALARY ) rank3,
	NTILE (2) OVER(PARTITION BY SUBSTR(EMP_ID, 1, 4) ORDER BY SALARY ) rank4,
	ROW_NUMBER () OVER(PARTITION BY SUBSTR(EMP_ID, 1, 4) ORDER BY SALARY ) rank5
FROM 
	TEMP 
GROUP BY 
	SUBSTR(EMP_ID, 1, 4),EMP_ID , EMP_NAME, SALARY ;
	
--sale_hists의 자료를 이용하여 '01' 사업장의 품목별 당일 판매액과
-- 당일까지의 누적 판매액을 구하는 쿼리
SELECT * FROM SALE_HIST sh ;

SELECT 
	sh.*,  SUM(SALE_AMT) OVER (PARTITION BY SALE_ITEM ORDER BY SALE_ITEM ROWS UNBOUNDED PRECEDING) 누계 
FROM 
	SALE_HIST sh 
WHERE 
	SALE_SITE = '01'
ORDER BY 
	SALE_ITEM , SALE_DATE ;
	
-- 일자별 사업장별 매출액과 사업장별 매출액의 3일 이동 평균을 구해보자(RANGE)
SELECT 
	SALE_DATE , SALE_SITE , SUM(SALE_AMT) ,
	AVG(SUM(SALE_AMT)) OVER (PARTITION BY SALE_SITE ORDER BY SALE_DATE RANGE INTERVAL '2' DAY PRECEDING) 이동평균 
FROM 
	SALE_HIST sh 
GROUP BY 
	SALE_DATE ,SALE_SITE , SALE_AMT ;